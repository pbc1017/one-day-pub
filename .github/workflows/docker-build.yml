name: Docker Build & Push

on:
  push:
    branches: [main, dev]
  workflow_dispatch:

# No global env needed

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service: [api, web]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate image metadata
        id: meta
        run: |
          SERVICE="${{ matrix.service }}"

          REGISTRY="${{ secrets.DOCKERHUB_USERNAME }}"

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="${REGISTRY}/kamf-${SERVICE}:latest,${REGISTRY}/kamf-${SERVICE}:${{ github.sha }}"
            SCAN_TAG="${REGISTRY}/kamf-${SERVICE}:${{ github.sha }}"
            ENV_SUFFIX="PROD"
          else
            # dev ë¸Œëžœì¹˜ ë˜ëŠ” workflow_dispatch
            TAGS="${REGISTRY}/kamf-${SERVICE}:dev,${REGISTRY}/kamf-${SERVICE}:dev-${{ github.sha }}"
            SCAN_TAG="${REGISTRY}/kamf-${SERVICE}:dev-${{ github.sha }}"
            ENV_SUFFIX="DEV"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "scan_tag=${SCAN_TAG}" >> $GITHUB_OUTPUT
          echo "env_suffix=${ENV_SUFFIX}" >> $GITHUB_OUTPUT
          echo "service=${SERVICE}" >> $GITHUB_OUTPUT

      - name: Build and push API image
        if: matrix.service == 'api'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/api/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha,scope=api
          cache-to: type=gha,mode=max,scope=api
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push Web image
        if: matrix.service == 'web'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ steps.meta.outputs.env_suffix == 'PROD' && secrets.NEXT_PUBLIC_API_URL_PROD || secrets.NEXT_PUBLIC_API_URL_DEV }}
            NEXT_PUBLIC_APP_URL=${{ steps.meta.outputs.env_suffix == 'PROD' && secrets.NEXT_PUBLIC_APP_URL_PROD || secrets.NEXT_PUBLIC_APP_URL_DEV }}
          cache-from: type=gha,scope=web
          cache-to: type=gha,mode=max,scope=web
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        if: success()
        with:
          image-ref: ${{ steps.meta.outputs.scan_tag }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.service }}.sarif'

      - name: Upload security scan results
        uses: github/codeql-action/upload-sarif@v3
        if: success()
        with:
          sarif_file: 'trivy-results-${{ matrix.service }}.sarif'
          category: 'docker-${{ matrix.service }}'

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build-and-push
    if: success() && github.ref == 'refs/heads/main'
    outputs:
      environment: ${{ steps.vars.outputs.environment }}
      domain: ${{ steps.vars.outputs.domain }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          # main ë¸Œëžœì¹˜ì—ì„œëŠ” í•­ìƒ production ë°°í¬
          DEPLOY_PATH="kamf"
          DOMAIN="kamf.site"
          API_PORT="8000"
          WEB_PORT="3000"
          DB_NAME="kamf_prod"
          IMAGE_TAG="latest"  # í•­ìƒ latest ì‚¬ìš©
          ENVIRONMENT="production"

          echo "deploy_path=${DEPLOY_PATH}" >> $GITHUB_OUTPUT
          echo "domain=${DOMAIN}" >> $GITHUB_OUTPUT
          echo "api_port=${API_PORT}" >> $GITHUB_OUTPUT
          echo "web_port=${WEB_PORT}" >> $GITHUB_OUTPUT
          echo "db_name=${DB_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "deployment_time=$(date '+%Y%m%d_%H%M%S')" >> $GITHUB_OUTPUT

      - name: Create deployment environment file
        run: |
          cat > .env.deploy << EOF
          # Deployment Configuration
          DOCKER_REGISTRY=${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_TAG=${{ steps.vars.outputs.image_tag }}
          DEPLOY_PATH=${{ steps.vars.outputs.deploy_path }}

          # Environment-specific Configuration
          NODE_ENV=production
          API_PORT=${{ steps.vars.outputs.api_port }}
          WEB_PORT=${{ steps.vars.outputs.web_port }}
          CORS_ORIGIN=http://${{ steps.vars.outputs.domain }}
          NEXT_PUBLIC_API_URL=http://${{ steps.vars.outputs.domain }}/api
          NEXT_PUBLIC_APP_URL=http://${{ steps.vars.outputs.domain }}

          # Database Configuration (ê³µìœ  MySQL)
          DB_HOST=kamf-mysql
          DB_PORT=3306
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ steps.vars.outputs.db_name }}
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}

          # JWT & Authentication
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=1h
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          REFRESH_TOKEN_EXPIRES_IN=7d
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}

          # Twilio SMS Configuration
          TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_SERVICE_SID=${{ secrets.TWILIO_SERVICE_SID }}

          # Deployment Metadata
          DEPLOYMENT_TIME=${{ steps.vars.outputs.deployment_time }}
          DEPLOYED_BY=${{ github.actor }}
          COMMIT_SHA=${{ github.sha }}
          ENVIRONMENT=${{ steps.vars.outputs.environment }}
          DOMAIN=${{ steps.vars.outputs.domain }}
          EOF

      - name: Copy deployment files to server
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          source: 'deploy/,.env.deploy'
          target: '/home/${{ secrets.SERVER_USERNAME }}/${{ steps.vars.outputs.deploy_path }}/'
          strip_components: 0
          overwrite: true

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            set -e
            echo "ðŸš€ Starting deployment to production server..."
            echo "ðŸ“¦ Image Tag: ${{ steps.vars.outputs.image_tag }}"
            echo "ðŸŒ Environment: ${{ steps.vars.outputs.environment }}"
            echo "ðŸŒ Domain: ${{ steps.vars.outputs.domain }}"
            echo "ðŸ‘¤ Deployed by: ${{ github.actor }}"
            echo "ðŸ”– Commit: ${{ github.sha }}"

            cd /home/${{ secrets.SERVER_USERNAME }}/${{ steps.vars.outputs.deploy_path }}
            if [ ! -f .env.deploy ]; then
              echo "âŒ .env.deploy file not found!"
              exit 1
            fi
            chmod +x deploy/scripts/deploy.sh
            echo "ðŸ“¥ Executing deployment script..."
            ./deploy/scripts/deploy.sh
            rm -f .env.deploy
            echo "âœ… Production deployment completed successfully!"

  notify:
    name: Notify Build & Deploy Result
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: Notify Slack
        if: vars.SLACK_WEBHOOK_URL != ''
        run: |
          STATUS="${{ needs.build-and-push.result }}"
          if [ "$STATUS" = "success" ]; then
            STATUS_KR="ì„±ê³µ"
          else
            STATUS_KR="ì‹¤íŒ¨"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{\"channel\":\"#ci-cd\",\"text\":\"ðŸ³ Docker ì´ë¯¸ì§€ ë¹Œë“œê°€ ${STATUS_KR}í–ˆìŠµë‹ˆë‹¤!\nðŸ“¦ ë¸Œëžœì¹˜: ${{ github.ref_name }}\nðŸ”– ì»¤ë°‹: ${{ github.sha }}\nðŸ‘¤ ìž‘ì„±ìž: ${{ github.actor }}\"}" \
            "${{ vars.SLACK_WEBHOOK_URL }}"
