name: Docker Build & Push

on:
  push:
    branches: [main, dev]
  workflow_dispatch:

# No global env needed

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}

    strategy:
      matrix:
        service: [api, web]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate image metadata
        id: meta
        run: |
          SERVICE="${{ matrix.service }}"

          REGISTRY="${{ secrets.DOCKERHUB_USERNAME }}"

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="${REGISTRY}/one-day-pub-${SERVICE}:latest,${REGISTRY}/one-day-pub-${SERVICE}:${{ github.sha }}"
            SCAN_TAG="${REGISTRY}/one-day-pub-${SERVICE}:${{ github.sha }}"
            ENV_SUFFIX="PROD"
          else
            # dev 브랜치 또는 workflow_dispatch
            TAGS="${REGISTRY}/one-day-pub-${SERVICE}:dev,${REGISTRY}/one-day-pub-${SERVICE}:dev-${{ github.sha }}"
            SCAN_TAG="${REGISTRY}/one-day-pub-${SERVICE}:dev-${{ github.sha }}"
            ENV_SUFFIX="DEV"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "scan_tag=${SCAN_TAG}" >> $GITHUB_OUTPUT
          echo "env_suffix=${ENV_SUFFIX}" >> $GITHUB_OUTPUT
          echo "service=${SERVICE}" >> $GITHUB_OUTPUT

      - name: Build and push API image
        if: matrix.service == 'api'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/api/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha,scope=${{ github.ref_name }}-api,ignore-error=true
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-api,ignore-error=true
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Build and push Web image
        if: matrix.service == 'web'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            NEXT_PUBLIC_API_URL=https://${{ vars.DOMAIN }}/api
            NEXT_PUBLIC_APP_URL=https://${{ vars.DOMAIN }}
          cache-from: type=gha,scope=${{ github.ref_name }}-web,ignore-error=true
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}-web,ignore-error=true
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        if: success()
        with:
          image-ref: ${{ steps.meta.outputs.scan_tag }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.service }}.sarif'

      - name: Upload security scan results
        uses: github/codeql-action/upload-sarif@v3
        if: success()
        with:
          sarif_file: 'trivy-results-${{ matrix.service }}.sarif'
          category: 'docker-${{ matrix.service }}'

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    needs: build-and-push
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      environment: ${{ steps.vars.outputs.environment }}
      domain: ${{ steps.vars.outputs.domain }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          # Environment Variables 활용 (브랜치에 따라 자동으로 다른 environment 적용)
          DEPLOY_PATH="${{ vars.DEPLOY_PATH }}"
          DOMAIN="${{ vars.DOMAIN }}"
          API_PORT="${{ vars.API_PORT }}"
          WEB_PORT="${{ vars.WEB_PORT }}"
          DB_NAME="${{ vars.DB_NAME }}"
          IMAGE_TAG="${{ vars.IMAGE_TAG }}"
          ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"

          echo "deploy_path=${DEPLOY_PATH}" >> $GITHUB_OUTPUT
          echo "domain=${DOMAIN}" >> $GITHUB_OUTPUT
          echo "api_port=${API_PORT}" >> $GITHUB_OUTPUT
          echo "web_port=${WEB_PORT}" >> $GITHUB_OUTPUT
          echo "db_name=${DB_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "deployment_time=$(date '+%Y%m%d_%H%M%S')" >> $GITHUB_OUTPUT

      - name: Create deployment environment file
        run: |
          cat > .env.deploy << EOF
          # Deployment Configuration
          DOCKER_REGISTRY=${{ secrets.DOCKERHUB_USERNAME }}
          IMAGE_TAG=${{ steps.vars.outputs.image_tag }}
          DEPLOY_PATH=${{ steps.vars.outputs.deploy_path }}

          # Environment-specific Configuration
          NODE_ENV=production
          API_PORT=${{ steps.vars.outputs.api_port }}
          WEB_PORT=${{ steps.vars.outputs.web_port }}
          CORS_ORIGIN=https://${{ steps.vars.outputs.domain }}
          NEXT_PUBLIC_API_URL=https://${{ steps.vars.outputs.domain }}/api
          NEXT_PUBLIC_APP_URL=https://${{ steps.vars.outputs.domain }}

          # Database Configuration (공유 MySQL)
          DB_HOST=one-day-pub-mysql
          DB_PORT=3306
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ steps.vars.outputs.db_name }}
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}

          # JWT & Authentication
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=1h
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          REFRESH_TOKEN_EXPIRES_IN=7d
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}

          # Twilio SMS Configuration
          TWILIO_ACCOUNT_SID=${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN=${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_SERVICE_SID=${{ secrets.TWILIO_SERVICE_SID }}

          # Mailgun Email Configuration
          MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
          MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
          MAILGUN_FROM_EMAIL=${{ secrets.MAILGUN_FROM_EMAIL }}

          # Deployment Metadata
          DEPLOYMENT_TIME=${{ steps.vars.outputs.deployment_time }}
          DEPLOYED_BY=${{ github.actor }}
          COMMIT_SHA=${{ github.sha }}
          ENVIRONMENT=${{ steps.vars.outputs.environment }}
          DOMAIN=${{ steps.vars.outputs.domain }}
          EOF

      - name: Copy deployment files to server
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          source: 'deploy/,.env.deploy'
          target: '/home/${{ secrets.SERVER_USERNAME }}/${{ steps.vars.outputs.deploy_path }}/'
          strip_components: 0
          overwrite: true

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            set -e
            echo "🚀 Starting deployment to ${{ steps.vars.outputs.environment }} server..."
            echo "📦 Image Tag: ${{ steps.vars.outputs.image_tag }}"
            echo "🌍 Environment: ${{ steps.vars.outputs.environment }}"
            echo "🌐 Domain: ${{ steps.vars.outputs.domain }}"
            echo "👤 Deployed by: ${{ github.actor }}"
            echo "🔖 Commit: ${{ github.sha }}"

            cd /home/${{ secrets.SERVER_USERNAME }}/${{ steps.vars.outputs.deploy_path }}
            if [ ! -f .env.deploy ]; then
              echo "❌ .env.deploy file not found!"
              exit 1
            fi

            # 환경에 따라 다른 배포 스크립트 실행
            if [ "${{ steps.vars.outputs.environment }}" = "production" ]; then
              chmod +x deploy/scripts/deploy-prod.sh
              echo "📥 Executing production deployment script..."
              ./deploy/scripts/deploy-prod.sh
              echo "✅ Production deployment completed successfully!"
            else
              chmod +x deploy/scripts/deploy-dev.sh
              echo "📥 Executing development deployment script..."
              ./deploy/scripts/deploy-dev.sh
              echo "✅ Development deployment completed successfully!"
            fi

            rm -f .env.deploy

  notify:
    name: Notify Build & Deploy Result
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: Notify Slack
        if: vars.SLACK_WEBHOOK_URL != ''
        run: |
          STATUS="${{ needs.build-and-push.result }}"
          if [ "$STATUS" = "success" ]; then
            STATUS_KR="성공"
          else
            STATUS_KR="실패"
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data "{\"channel\":\"#ci-cd\",\"text\":\"🐳 Docker 이미지 빌드가 ${STATUS_KR}했습니다!\n📦 브랜치: ${{ github.ref_name }}\n🔖 커밋: ${{ github.sha }}\n👤 작성자: ${{ github.actor }}\"}" \
            "${{ vars.SLACK_WEBHOOK_URL }}"
